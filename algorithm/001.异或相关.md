### 异或操作

1. 0^N = N;
2. N^N = 0;
3. 满足交换律和结合律
   a^b = b^a;
   a^b^c = a^(b^c)

4.

```js
a = '甲';
b = '乙';
a ^= b; //  a = "甲" ^ "乙" 、  b =  "乙"
b ^= a; // b= "甲" ^ "乙"  ^ "乙"  (因为乙^乙 = 0 ，所以b = 甲)、 a = "甲" ^ "乙"
a ^= b; // a = "甲" ^ "乙" ^ ”甲“  (因为甲^甲 = 0 ，所以a = 甲 )
```

#### 异或相关题目

1. 有一种数出现了奇数次，其他数出现了偶数次，怎么求出现了奇数次的这个数.

`解题思路`：   
+ 出现偶数次的数，异或等于0, 0和这个数（这个数出现三次，那么两次异或也是0，再次异或就是这个数）   
+ 基于上述，重头异或到结尾就可以的到结果  

```js
const arr = [1, 2, 2, 3, 3, 4, 4];
const result = arr.reduce((prev, item) => (prev ^= item), 0);
```

2. 两种数出现了奇数次，其他数出现了偶数次，求这两个数
`解题思路`： 

1. 这两个数肯定有二进制表示后，肯定有某一位是不一样的，按照这个进行分组，两个出现的奇数次的数会分在不同的数组里面【出现偶数次的数肯定一直会被分在同一侧】，
2. 如何找到某一位不一样，将整个数字异或一下(相同位（0| 1），出现奇数次就是 这个位的值（0|1），出现偶数个这一位肯定是0) 得到`eor`(就得到了这两个出现奇数次的数a^b) ,把这个数用二进制标识，有一位是1（假如是第七位是1）
3. 然后按照是1的哪一位（假如是第七位是1）的哪一位去异或， 此时的到结果`eor'`,这个结果要么是a要么是b；
4. 然后再异或`eor` 和 `eor'`就得到另一个数


```js

//*** */ 如何找到 最右侧位位1的数字

//  假设 eor的二进制表示如下
//         eor :  100100
//         取反 :  011011
//        取反+1:  011100
// eor & (取反+1): 000100  按位与
let rightBitIsOne = eor & (~eor + 1); //! 提取最右侧是1的那个数   二进制100 这个数也就是4

```

